// 线段树模版    
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cstdlib>
using namespace std;
#define lson x << 1
#define rson (x << 1) + 1
const int MAXN = 200000 + 5;

struct Node{
	int sum;
	int l ,r;
}tree[MAXN << 2]; 
int lazy[MAXN << 2];   //置 -1 
int a[MAXN];
int ans;
int n, m;

//对于建树更新查询的操作 

void Push_up(int x){    //操作 
	tree[x].sum = tree[lson].sum + tree[rson].sum;
}

void Push_down(int x){
	if(lazy[x] != -1){
		int l = tree[x].l, r = tree[x].r; 
		lazy[lson] = lazy[x];  lazy[rson] = lazy[x];
		lazy[x] = -1; 
		int mid = (l + r) >> 1;
		tree[lson].sum = (mid - l + 1)* lazy[lson];
		tree[rson].sum = (r - mid)* lazy[rson];
	}
}

void Creat(int x, int L, int R){
	if(L > R) return;
	tree[x].l = L; tree[x].r = R;
	if(L == R) {
		//赋值操作 
		tree[x].sum = 1; 
		return; 
	}
	int mid = (L + R) >> 1;
	Creat(lson, L, mid);
	Creat(rson, mid + 1, R);
	push_up(x);
}

void Update_one(int x, int pos, int val){     //Update_one(1, p, v);
	
	int L = tree[x].l, R = tree[x].r; 
    if(L == R && L == pos) {
	    tree[x].sum = val; 
		return; 
	}                                            // 端点更新 
    int mid = (L + R) >> 1;
    if(pos <= mid) Update_one(lson, pos, val);
    if(pos > mid)  Update_one(rson, pos, val);
    
    push_up(x);
}

void Update_seg(int x, int a, int b, int val){  //Update_seg(1, l, r, V);
	int L = tree[x].l, R = tree[x].r;
    if(L >= a && R <= b) {
	    tree[x].sum = val * (R - L + 1 );          //此处是区间和 
		lazy[x] = val; 
		return; 
    }  
	push_down(x); 
    int mid = (L + R) / 2;
    if(a <= mid) Update_seg(lson, a, b, val);
    if(b > mid)  Update_seg(rson, a, b, val);
    push_up(x);
}

void Query(int x, int l, int r){             //Query(1, A, B);
	int L = tree[x].l, R = tree[x].r;
    if(l <= L && r >= R) {
											//操作
    	ans = max(ans, tree[x].sum);
	    return ;
	}                                     //找到区间或子区间 
    int mid = (L + R) >> 1;
    if(l <= mid) Query(lson, l, r);
    if(r >= mid+1) Query(rson, l , r);
}

//计数器
/* 
逆序数求得之后，把第一个数移到最后的逆序数是可以直接得到的。
比如原来的逆序数是ans,把a[0]移到最后后，减少逆序数a[0]，同时增加逆序数n-a[0]-1个
就是ans-a[0]+n-a[0]-1; 
类似树状数组的区间加权与求和 
*/ 
/*
线段树对逆序对的算法中， 初始化所有节点为0， 利用时效性， 每次算出比其大的个数， 
往后区间标记自己的存在，并维护线段树，统计区间内的元素个数即可
*/ 


void Add(int x,int pos, int val){   //add(1, a[i], 1);  1到a[i]区间全加上一 
	tree[x].sum += val;
	if(tree[x].l == tree[x].r) return;
	int mid = (tree[x].l + tree[x].r) >> 1;
	if(mid >= pos) Add(lson, pos, val);
	else Add(rson, pos, val);
}

void Sum(int x, int l, int r){   //Sum(1, a[i], n-1);   a[i]到n-1区间的和 
    if(tree[x].l >= l && tree[x].r <= r) {
	    ans += tree[x].sum; 
		return ;
    } 
    int mid = (tree[x].l + tree[x].r) >> 1;
    if(l <= mid) Sum(lson, l, r);
    if(r >= mid + 1) Sum(rson, l, r);
}